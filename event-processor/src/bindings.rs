// Generated by `wit-bindgen` 0.25.0. DO NOT EDIT!
// Options used:
#[allow(dead_code)]
pub mod exports {
    #[allow(dead_code)]
    pub mod timeline {
        #[allow(dead_code)]
        pub mod event_processor {
            #[allow(dead_code, clippy::all)]
            pub mod api {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                #[derive(Clone)]
                pub enum EventValue {
                    StringValue(_rt::String),
                    IntValue(i64),
                    FloatValue(f64),
                    BoolValue(bool),
                }
                impl ::core::fmt::Debug for EventValue {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            EventValue::StringValue(e) => {
                                f.debug_tuple("EventValue::StringValue").field(e).finish()
                            }
                            EventValue::IntValue(e) => {
                                f.debug_tuple("EventValue::IntValue").field(e).finish()
                            }
                            EventValue::FloatValue(e) => {
                                f.debug_tuple("EventValue::FloatValue").field(e).finish()
                            }
                            EventValue::BoolValue(e) => {
                                f.debug_tuple("EventValue::BoolValue").field(e).finish()
                            }
                        }
                    }
                }
                #[derive(Clone)]
                pub struct Event {
                    pub time: u64,
                    pub event: _rt::Vec<(_rt::String, EventValue)>,
                }
                impl ::core::fmt::Debug for Event {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Event")
                            .field("time", &self.time)
                            .field("event", &self.event)
                            .finish()
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct TimePeriod {
                    pub t1: u64,
                    pub t2: Option<u64>,
                }
                impl ::core::fmt::Debug for TimePeriod {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("TimePeriod")
                            .field("t1", &self.t1)
                            .field("t2", &self.t2)
                            .finish()
                    }
                }
                #[derive(Clone)]
                pub struct TimelineResultPoint {
                    pub time_period: TimePeriod,
                    pub value: EventValue,
                }
                impl ::core::fmt::Debug for TimelineResultPoint {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("TimelineResultPoint")
                            .field("time-period", &self.time_period)
                            .field("value", &self.value)
                            .finish()
                    }
                }
                #[derive(Clone)]
                pub struct TimelineResult {
                    pub results: _rt::Vec<TimelineResultPoint>,
                }
                impl ::core::fmt::Debug for TimelineResult {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("TimelineResult").field("results", &self.results).finish()
                    }
                }
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, PartialEq)]
                pub enum EventPredicateOp {
                    Equal,
                    GreaterThan,
                    LessThan,
                }
                impl ::core::fmt::Debug for EventPredicateOp {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                            EventPredicateOp::Equal => {
                                f.debug_tuple("EventPredicateOp::Equal").finish()
                            }
                            EventPredicateOp::GreaterThan => {
                                f.debug_tuple("EventPredicateOp::GreaterThan").finish()
                            }
                            EventPredicateOp::LessThan => {
                                f.debug_tuple("EventPredicateOp::LessThan").finish()
                            }
                        }
                    }
                }

                impl EventPredicateOp {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> EventPredicateOp {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }

                        match val {
                            0 => EventPredicateOp::Equal,
                            1 => EventPredicateOp::GreaterThan,
                            2 => EventPredicateOp::LessThan,

                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }

                #[derive(Clone)]
                pub struct EventPredicate {
                    pub col_name: _rt::String,
                    pub value: EventValue,
                    pub op: EventPredicateOp,
                }
                impl ::core::fmt::Debug for EventPredicate {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("EventPredicate")
                            .field("col-name", &self.col_name)
                            .field("value", &self.value)
                            .field("op", &self.op)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_initialize_latest_event_state_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result1 = T::initialize_latest_event_state(_rt::string_lift(bytes0));
                    let ptr2 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result1 {
                        Ok(e) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                            let vec3 = (e.into_bytes()).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *ptr2.add(8).cast::<usize>() = len3;
                            *ptr2.add(4).cast::<*mut u8>() = ptr3.cast_mut();
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            let vec4 = (e.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *ptr2.add(8).cast::<usize>() = len4;
                            *ptr2.add(4).cast::<*mut u8>() = ptr4.cast_mut();
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_initialize_latest_event_state<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(4).cast::<*mut u8>();
                            let l2 = *arg0.add(8).cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                        _ => {
                            let l3 = *arg0.add(4).cast::<*mut u8>();
                            let l4 = *arg0.add(8).cast::<usize>();
                            _rt::cabi_dealloc(l3, l4, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_initialize_tl_has_existed_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: ::core::mem::MaybeUninit<u64>,
                    arg4: usize,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let v2 = match arg2 {
                        0 => {
                            let e2 = {
                                let len1 = arg4;
                                let bytes1 = _rt::Vec::from_raw_parts(
                                    arg3.as_ptr().cast::<*mut u8>().read().cast(),
                                    len1,
                                    len1,
                                );

                                _rt::string_lift(bytes1)
                            };
                            EventValue::StringValue(e2)
                        }
                        1 => {
                            let e2 = arg3.assume_init() as i64;
                            EventValue::IntValue(e2)
                        }
                        2 => {
                            let e2 = f64::from_bits(arg3.assume_init() as i64 as u64);
                            EventValue::FloatValue(e2)
                        }
                        n => {
                            debug_assert_eq!(n, 3, "invalid enum discriminant");
                            let e2 = _rt::bool_lift(arg3.assume_init() as i64 as i32 as u8);
                            EventValue::BoolValue(e2)
                        }
                    };
                    let result3 = T::initialize_tl_has_existed(EventPredicate {
                        col_name: _rt::string_lift(bytes0),
                        value: v2,
                        op: EventPredicateOp::_lift(arg5 as u8),
                    });
                    let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result3 {
                        Ok(e) => {
                            *ptr4.add(0).cast::<u8>() = (0i32) as u8;
                            let vec5 = (e.into_bytes()).into_boxed_slice();
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            ::core::mem::forget(vec5);
                            *ptr4.add(8).cast::<usize>() = len5;
                            *ptr4.add(4).cast::<*mut u8>() = ptr5.cast_mut();
                        }
                        Err(e) => {
                            *ptr4.add(0).cast::<u8>() = (1i32) as u8;
                            let vec6 = (e.into_bytes()).into_boxed_slice();
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            ::core::mem::forget(vec6);
                            *ptr4.add(8).cast::<usize>() = len6;
                            *ptr4.add(4).cast::<*mut u8>() = ptr6.cast_mut();
                        }
                    };
                    ptr4
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_initialize_tl_has_existed<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(4).cast::<*mut u8>();
                            let l2 = *arg0.add(8).cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                        _ => {
                            let l3 = *arg0.add(4).cast::<*mut u8>();
                            let l4 = *arg0.add(8).cast::<usize>();
                            _rt::cabi_dealloc(l3, l4, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_initialize_tl_has_existed_within_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: ::core::mem::MaybeUninit<u64>,
                    arg4: usize,
                    arg5: i32,
                    arg6: i64,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let v2 = match arg2 {
                        0 => {
                            let e2 = {
                                let len1 = arg4;
                                let bytes1 = _rt::Vec::from_raw_parts(
                                    arg3.as_ptr().cast::<*mut u8>().read().cast(),
                                    len1,
                                    len1,
                                );

                                _rt::string_lift(bytes1)
                            };
                            EventValue::StringValue(e2)
                        }
                        1 => {
                            let e2 = arg3.assume_init() as i64;
                            EventValue::IntValue(e2)
                        }
                        2 => {
                            let e2 = f64::from_bits(arg3.assume_init() as i64 as u64);
                            EventValue::FloatValue(e2)
                        }
                        n => {
                            debug_assert_eq!(n, 3, "invalid enum discriminant");
                            let e2 = _rt::bool_lift(arg3.assume_init() as i64 as i32 as u8);
                            EventValue::BoolValue(e2)
                        }
                    };
                    let result3 = T::initialize_tl_has_existed_within(
                        EventPredicate {
                            col_name: _rt::string_lift(bytes0),
                            value: v2,
                            op: EventPredicateOp::_lift(arg5 as u8),
                        },
                        arg6 as u64,
                    );
                    let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result3 {
                        Ok(e) => {
                            *ptr4.add(0).cast::<u8>() = (0i32) as u8;
                            let vec5 = (e.into_bytes()).into_boxed_slice();
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            ::core::mem::forget(vec5);
                            *ptr4.add(8).cast::<usize>() = len5;
                            *ptr4.add(4).cast::<*mut u8>() = ptr5.cast_mut();
                        }
                        Err(e) => {
                            *ptr4.add(0).cast::<u8>() = (1i32) as u8;
                            let vec6 = (e.into_bytes()).into_boxed_slice();
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            ::core::mem::forget(vec6);
                            *ptr4.add(8).cast::<usize>() = len6;
                            *ptr4.add(4).cast::<*mut u8>() = ptr6.cast_mut();
                        }
                    };
                    ptr4
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_initialize_tl_has_existed_within<T: Guest>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(4).cast::<*mut u8>();
                            let l2 = *arg0.add(8).cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                        _ => {
                            let l3 = *arg0.add(4).cast::<*mut u8>();
                            let l4 = *arg0.add(8).cast::<usize>();
                            _rt::cabi_dealloc(l3, l4, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_add_event_cabi<T: Guest>(
                    arg0: i64,
                    arg1: *mut u8,
                    arg2: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let base11 = arg1;
                    let len11 = arg2;
                    let mut result11 = _rt::Vec::with_capacity(len11);
                    for i in 0..len11 {
                        let base = base11.add(i * 24);
                        let e11 = {
                            let l0 = *base.add(0).cast::<*mut u8>();
                            let l1 = *base.add(4).cast::<usize>();
                            let len2 = l1;
                            let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                            let l3 = i32::from(*base.add(8).cast::<u8>());
                            let v10 = match l3 {
                                0 => {
                                    let e10 = {
                                        let l4 = *base.add(16).cast::<*mut u8>();
                                        let l5 = *base.add(20).cast::<usize>();
                                        let len6 = l5;
                                        let bytes6 =
                                            _rt::Vec::from_raw_parts(l4.cast(), len6, len6);

                                        _rt::string_lift(bytes6)
                                    };
                                    EventValue::StringValue(e10)
                                }
                                1 => {
                                    let e10 = {
                                        let l7 = *base.add(16).cast::<i64>();

                                        l7
                                    };
                                    EventValue::IntValue(e10)
                                }
                                2 => {
                                    let e10 = {
                                        let l8 = *base.add(16).cast::<f64>();

                                        l8
                                    };
                                    EventValue::FloatValue(e10)
                                }
                                n => {
                                    debug_assert_eq!(n, 3, "invalid enum discriminant");
                                    let e10 = {
                                        let l9 = i32::from(*base.add(16).cast::<u8>());

                                        _rt::bool_lift(l9 as u8)
                                    };
                                    EventValue::BoolValue(e10)
                                }
                            };

                            (_rt::string_lift(bytes2), v10)
                        };
                        result11.push(e11);
                    }
                    _rt::cabi_dealloc(base11, len11 * 24, 8);
                    let result12 = T::add_event(Event { time: arg0 as u64, event: result11 });
                    let ptr13 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result12 {
                        Ok(e) => {
                            *ptr13.add(0).cast::<u8>() = (0i32) as u8;
                            let vec14 = (e.into_bytes()).into_boxed_slice();
                            let ptr14 = vec14.as_ptr().cast::<u8>();
                            let len14 = vec14.len();
                            ::core::mem::forget(vec14);
                            *ptr13.add(8).cast::<usize>() = len14;
                            *ptr13.add(4).cast::<*mut u8>() = ptr14.cast_mut();
                        }
                        Err(e) => {
                            *ptr13.add(0).cast::<u8>() = (1i32) as u8;
                            let vec15 = (e.into_bytes()).into_boxed_slice();
                            let ptr15 = vec15.as_ptr().cast::<u8>();
                            let len15 = vec15.len();
                            ::core::mem::forget(vec15);
                            *ptr13.add(8).cast::<usize>() = len15;
                            *ptr13.add(4).cast::<*mut u8>() = ptr15.cast_mut();
                        }
                    };
                    ptr13
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_add_event<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(4).cast::<*mut u8>();
                            let l2 = *arg0.add(8).cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                        _ => {
                            let l3 = *arg0.add(4).cast::<*mut u8>();
                            let l4 = *arg0.add(8).cast::<usize>();
                            _rt::cabi_dealloc(l3, l4, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_latest_event_to_state_cabi<T: Guest>(arg0: i64) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::latest_event_to_state(arg0 as u64);
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            let TimelineResult { results: results2 } = e;
                            let vec6 = results2;
                            let len6 = vec6.len();
                            let layout6 =
                                _rt::alloc::Layout::from_size_align_unchecked(vec6.len() * 40, 8);
                            let result6 = if layout6.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout6).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout6);
                                }
                                ptr
                            } else {
                                {
                                    ::core::ptr::null_mut()
                                }
                            };
                            for (i, e) in vec6.into_iter().enumerate() {
                                let base = result6.add(i * 40);
                                {
                                    let TimelineResultPoint {
                                        time_period: time_period3,
                                        value: value3,
                                    } = e;
                                    let TimePeriod { t1: t14, t2: t24 } = time_period3;
                                    *base.add(0).cast::<i64>() = _rt::as_i64(t14);
                                    match t24 {
                                        Some(e) => {
                                            *base.add(8).cast::<u8>() = (1i32) as u8;
                                            *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        None => {
                                            *base.add(8).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match value3 {
                                        EventValue::StringValue(e) => {
                                            *base.add(24).cast::<u8>() = (0i32) as u8;
                                            let vec5 = (e.into_bytes()).into_boxed_slice();
                                            let ptr5 = vec5.as_ptr().cast::<u8>();
                                            let len5 = vec5.len();
                                            ::core::mem::forget(vec5);
                                            *base.add(36).cast::<usize>() = len5;
                                            *base.add(32).cast::<*mut u8>() = ptr5.cast_mut();
                                        }
                                        EventValue::IntValue(e) => {
                                            *base.add(24).cast::<u8>() = (1i32) as u8;
                                            *base.add(32).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        EventValue::FloatValue(e) => {
                                            *base.add(24).cast::<u8>() = (2i32) as u8;
                                            *base.add(32).cast::<f64>() = _rt::as_f64(e);
                                        }
                                        EventValue::BoolValue(e) => {
                                            *base.add(24).cast::<u8>() = (3i32) as u8;
                                            *base.add(32).cast::<u8>() = (match e {
                                                true => 1,
                                                false => 0,
                                            })
                                                as u8;
                                        }
                                    }
                                }
                            }
                            *ptr1.add(8).cast::<usize>() = len6;
                            *ptr1.add(4).cast::<*mut u8>() = result6;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            let vec7 = (e.into_bytes()).into_boxed_slice();
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();
                            ::core::mem::forget(vec7);
                            *ptr1.add(8).cast::<usize>() = len7;
                            *ptr1.add(4).cast::<*mut u8>() = ptr7.cast_mut();
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_latest_event_to_state<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l4 = *arg0.add(4).cast::<*mut u8>();
                            let l5 = *arg0.add(8).cast::<usize>();
                            let base6 = l4;
                            let len6 = l5;
                            for i in 0..len6 {
                                let base = base6.add(i * 40);
                                {
                                    let l1 = i32::from(*base.add(24).cast::<u8>());
                                    match l1 {
                                        0 => {
                                            let l2 = *base.add(32).cast::<*mut u8>();
                                            let l3 = *base.add(36).cast::<usize>();
                                            _rt::cabi_dealloc(l2, l3, 1);
                                        }
                                        1 => (),
                                        2 => (),
                                        _ => (),
                                    }
                                }
                            }
                            _rt::cabi_dealloc(base6, len6 * 40, 8);
                        }
                        _ => {
                            let l7 = *arg0.add(4).cast::<*mut u8>();
                            let l8 = *arg0.add(8).cast::<usize>();
                            _rt::cabi_dealloc(l7, l8, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_tl_has_existed_cabi<T: Guest>(arg0: i64) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::tl_has_existed(arg0 as u64);
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            let TimelineResult { results: results2 } = e;
                            let vec6 = results2;
                            let len6 = vec6.len();
                            let layout6 =
                                _rt::alloc::Layout::from_size_align_unchecked(vec6.len() * 40, 8);
                            let result6 = if layout6.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout6).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout6);
                                }
                                ptr
                            } else {
                                {
                                    ::core::ptr::null_mut()
                                }
                            };
                            for (i, e) in vec6.into_iter().enumerate() {
                                let base = result6.add(i * 40);
                                {
                                    let TimelineResultPoint {
                                        time_period: time_period3,
                                        value: value3,
                                    } = e;
                                    let TimePeriod { t1: t14, t2: t24 } = time_period3;
                                    *base.add(0).cast::<i64>() = _rt::as_i64(t14);
                                    match t24 {
                                        Some(e) => {
                                            *base.add(8).cast::<u8>() = (1i32) as u8;
                                            *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        None => {
                                            *base.add(8).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match value3 {
                                        EventValue::StringValue(e) => {
                                            *base.add(24).cast::<u8>() = (0i32) as u8;
                                            let vec5 = (e.into_bytes()).into_boxed_slice();
                                            let ptr5 = vec5.as_ptr().cast::<u8>();
                                            let len5 = vec5.len();
                                            ::core::mem::forget(vec5);
                                            *base.add(36).cast::<usize>() = len5;
                                            *base.add(32).cast::<*mut u8>() = ptr5.cast_mut();
                                        }
                                        EventValue::IntValue(e) => {
                                            *base.add(24).cast::<u8>() = (1i32) as u8;
                                            *base.add(32).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        EventValue::FloatValue(e) => {
                                            *base.add(24).cast::<u8>() = (2i32) as u8;
                                            *base.add(32).cast::<f64>() = _rt::as_f64(e);
                                        }
                                        EventValue::BoolValue(e) => {
                                            *base.add(24).cast::<u8>() = (3i32) as u8;
                                            *base.add(32).cast::<u8>() = (match e {
                                                true => 1,
                                                false => 0,
                                            })
                                                as u8;
                                        }
                                    }
                                }
                            }
                            *ptr1.add(8).cast::<usize>() = len6;
                            *ptr1.add(4).cast::<*mut u8>() = result6;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            let vec7 = (e.into_bytes()).into_boxed_slice();
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();
                            ::core::mem::forget(vec7);
                            *ptr1.add(8).cast::<usize>() = len7;
                            *ptr1.add(4).cast::<*mut u8>() = ptr7.cast_mut();
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_tl_has_existed<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l4 = *arg0.add(4).cast::<*mut u8>();
                            let l5 = *arg0.add(8).cast::<usize>();
                            let base6 = l4;
                            let len6 = l5;
                            for i in 0..len6 {
                                let base = base6.add(i * 40);
                                {
                                    let l1 = i32::from(*base.add(24).cast::<u8>());
                                    match l1 {
                                        0 => {
                                            let l2 = *base.add(32).cast::<*mut u8>();
                                            let l3 = *base.add(36).cast::<usize>();
                                            _rt::cabi_dealloc(l2, l3, 1);
                                        }
                                        1 => (),
                                        2 => (),
                                        _ => (),
                                    }
                                }
                            }
                            _rt::cabi_dealloc(base6, len6 * 40, 8);
                        }
                        _ => {
                            let l7 = *arg0.add(4).cast::<*mut u8>();
                            let l8 = *arg0.add(8).cast::<usize>();
                            _rt::cabi_dealloc(l7, l8, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_tl_has_existed_within_cabi<T: Guest>(arg0: i64) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let result0 = T::tl_has_existed_within(arg0 as u64);
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            let TimelineResult { results: results2 } = e;
                            let vec6 = results2;
                            let len6 = vec6.len();
                            let layout6 =
                                _rt::alloc::Layout::from_size_align_unchecked(vec6.len() * 40, 8);
                            let result6 = if layout6.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout6).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout6);
                                }
                                ptr
                            } else {
                                {
                                    ::core::ptr::null_mut()
                                }
                            };
                            for (i, e) in vec6.into_iter().enumerate() {
                                let base = result6.add(i * 40);
                                {
                                    let TimelineResultPoint {
                                        time_period: time_period3,
                                        value: value3,
                                    } = e;
                                    let TimePeriod { t1: t14, t2: t24 } = time_period3;
                                    *base.add(0).cast::<i64>() = _rt::as_i64(t14);
                                    match t24 {
                                        Some(e) => {
                                            *base.add(8).cast::<u8>() = (1i32) as u8;
                                            *base.add(16).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        None => {
                                            *base.add(8).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match value3 {
                                        EventValue::StringValue(e) => {
                                            *base.add(24).cast::<u8>() = (0i32) as u8;
                                            let vec5 = (e.into_bytes()).into_boxed_slice();
                                            let ptr5 = vec5.as_ptr().cast::<u8>();
                                            let len5 = vec5.len();
                                            ::core::mem::forget(vec5);
                                            *base.add(36).cast::<usize>() = len5;
                                            *base.add(32).cast::<*mut u8>() = ptr5.cast_mut();
                                        }
                                        EventValue::IntValue(e) => {
                                            *base.add(24).cast::<u8>() = (1i32) as u8;
                                            *base.add(32).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        EventValue::FloatValue(e) => {
                                            *base.add(24).cast::<u8>() = (2i32) as u8;
                                            *base.add(32).cast::<f64>() = _rt::as_f64(e);
                                        }
                                        EventValue::BoolValue(e) => {
                                            *base.add(24).cast::<u8>() = (3i32) as u8;
                                            *base.add(32).cast::<u8>() = (match e {
                                                true => 1,
                                                false => 0,
                                            })
                                                as u8;
                                        }
                                    }
                                }
                            }
                            *ptr1.add(8).cast::<usize>() = len6;
                            *ptr1.add(4).cast::<*mut u8>() = result6;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            let vec7 = (e.into_bytes()).into_boxed_slice();
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();
                            ::core::mem::forget(vec7);
                            *ptr1.add(8).cast::<usize>() = len7;
                            *ptr1.add(4).cast::<*mut u8>() = ptr7.cast_mut();
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_tl_has_existed_within<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l4 = *arg0.add(4).cast::<*mut u8>();
                            let l5 = *arg0.add(8).cast::<usize>();
                            let base6 = l4;
                            let len6 = l5;
                            for i in 0..len6 {
                                let base = base6.add(i * 40);
                                {
                                    let l1 = i32::from(*base.add(24).cast::<u8>());
                                    match l1 {
                                        0 => {
                                            let l2 = *base.add(32).cast::<*mut u8>();
                                            let l3 = *base.add(36).cast::<usize>();
                                            _rt::cabi_dealloc(l2, l3, 1);
                                        }
                                        1 => (),
                                        2 => (),
                                        _ => (),
                                    }
                                }
                            }
                            _rt::cabi_dealloc(base6, len6 * 40, 8);
                        }
                        _ => {
                            let l7 = *arg0.add(4).cast::<*mut u8>();
                            let l8 = *arg0.add(8).cast::<usize>();
                            _rt::cabi_dealloc(l7, l8, 1);
                        }
                    }
                }
                pub trait Guest {
                    fn initialize_latest_event_state(
                        event_col_name: _rt::String,
                    ) -> Result<_rt::String, _rt::String>;
                    fn initialize_tl_has_existed(
                        event_predicate: EventPredicate,
                    ) -> Result<_rt::String, _rt::String>;
                    fn initialize_tl_has_existed_within(
                        event_predicate: EventPredicate,
                        time: u64,
                    ) -> Result<_rt::String, _rt::String>;
                    fn add_event(event: Event) -> Result<_rt::String, _rt::String>;
                    fn latest_event_to_state(t1: u64) -> Result<TimelineResult, _rt::String>;
                    fn tl_has_existed(t1: u64) -> Result<TimelineResult, _rt::String>;
                    fn tl_has_existed_within(t1: u64) -> Result<TimelineResult, _rt::String>;
                }
                #[doc(hidden)]

                macro_rules! __export_timeline_event_processor_api_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "timeline:event-processor/api#initialize-latest-event-state"]
    unsafe extern "C" fn export_initialize_latest_event_state(arg0: *mut u8,arg1: usize,) -> *mut u8 {
      $($path_to_types)*::_export_initialize_latest_event_state_cabi::<$ty>(arg0, arg1)
    }
    #[export_name = "cabi_post_timeline:event-processor/api#initialize-latest-event-state"]
    unsafe extern "C" fn _post_return_initialize_latest_event_state(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_initialize_latest_event_state::<$ty>(arg0)
    }
    #[export_name = "timeline:event-processor/api#initialize-tl-has-existed"]
    unsafe extern "C" fn export_initialize_tl_has_existed(arg0: *mut u8,arg1: usize,arg2: i32,arg3: ::core::mem::MaybeUninit::<u64>,arg4: usize,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_initialize_tl_has_existed_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
    #[export_name = "cabi_post_timeline:event-processor/api#initialize-tl-has-existed"]
    unsafe extern "C" fn _post_return_initialize_tl_has_existed(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_initialize_tl_has_existed::<$ty>(arg0)
    }
    #[export_name = "timeline:event-processor/api#initialize-tl-has-existed-within"]
    unsafe extern "C" fn export_initialize_tl_has_existed_within(arg0: *mut u8,arg1: usize,arg2: i32,arg3: ::core::mem::MaybeUninit::<u64>,arg4: usize,arg5: i32,arg6: i64,) -> *mut u8 {
      $($path_to_types)*::_export_initialize_tl_has_existed_within_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
    }
    #[export_name = "cabi_post_timeline:event-processor/api#initialize-tl-has-existed-within"]
    unsafe extern "C" fn _post_return_initialize_tl_has_existed_within(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_initialize_tl_has_existed_within::<$ty>(arg0)
    }
    #[export_name = "timeline:event-processor/api#add-event"]
    unsafe extern "C" fn export_add_event(arg0: i64,arg1: *mut u8,arg2: usize,) -> *mut u8 {
      $($path_to_types)*::_export_add_event_cabi::<$ty>(arg0, arg1, arg2)
    }
    #[export_name = "cabi_post_timeline:event-processor/api#add-event"]
    unsafe extern "C" fn _post_return_add_event(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_add_event::<$ty>(arg0)
    }
    #[export_name = "timeline:event-processor/api#latest-event-to-state"]
    unsafe extern "C" fn export_latest_event_to_state(arg0: i64,) -> *mut u8 {
      $($path_to_types)*::_export_latest_event_to_state_cabi::<$ty>(arg0)
    }
    #[export_name = "cabi_post_timeline:event-processor/api#latest-event-to-state"]
    unsafe extern "C" fn _post_return_latest_event_to_state(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_latest_event_to_state::<$ty>(arg0)
    }
    #[export_name = "timeline:event-processor/api#tl-has-existed"]
    unsafe extern "C" fn export_tl_has_existed(arg0: i64,) -> *mut u8 {
      $($path_to_types)*::_export_tl_has_existed_cabi::<$ty>(arg0)
    }
    #[export_name = "cabi_post_timeline:event-processor/api#tl-has-existed"]
    unsafe extern "C" fn _post_return_tl_has_existed(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_tl_has_existed::<$ty>(arg0)
    }
    #[export_name = "timeline:event-processor/api#tl-has-existed-within"]
    unsafe extern "C" fn export_tl_has_existed_within(arg0: i64,) -> *mut u8 {
      $($path_to_types)*::_export_tl_has_existed_within_cabi::<$ty>(arg0)
    }
    #[export_name = "cabi_post_timeline:event-processor/api#tl-has-existed-within"]
    unsafe extern "C" fn _post_return_tl_has_existed_within(arg0: *mut u8,) {
      $($path_to_types)*::__post_return_tl_has_existed_within::<$ty>(arg0)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_timeline_event_processor_api_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            }
        }
    }
}
mod _rt {
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;

    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr as *mut u8, layout);
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }

    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }

    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }

    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }

    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }

    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }

    pub fn as_f64<T: AsF64>(t: T) -> f64 {
        t.as_f64()
    }

    pub trait AsF64 {
        fn as_f64(self) -> f64;
    }

    impl<'a, T: Copy + AsF64> AsF64 for &'a T {
        fn as_f64(self) -> f64 {
            (*self).as_f64()
        }
    }

    impl AsF64 for f64 {
        #[inline]
        fn as_f64(self) -> f64 {
            self as f64
        }
    }
    pub use alloc_crate::alloc;
    extern crate alloc as alloc_crate;
}

/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_event_processor_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::exports::timeline::event_processor::api::__export_timeline_event_processor_api_cabi!($ty with_types_in $($path_to_types_root)*::exports::timeline::event_processor::api);
  )
}
#[doc(inline)]
pub(crate) use __export_event_processor_impl as export;

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.25.0:event-processor:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 842] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xc4\x05\x01A\x02\x01\
A\x02\x01B\x20\x01q\x04\x0cstring-value\x01s\0\x09int-value\x01x\0\x0bfloat-valu\
e\x01u\0\x0abool-value\x01\x7f\0\x04\0\x0bevent-value\x03\0\0\x01o\x02s\x01\x01p\
\x02\x01r\x02\x04timew\x05event\x03\x04\0\x05event\x03\0\x04\x01kw\x01r\x02\x02t\
1w\x02t2\x06\x04\0\x0btime-period\x03\0\x07\x01r\x02\x0btime-period\x08\x05value\
\x01\x04\0\x15timeline-result-point\x03\0\x09\x01p\x0a\x01r\x01\x07results\x0b\x04\
\0\x0ftimeline-result\x03\0\x0c\x01m\x03\x05equal\x0cgreater-than\x09less-than\x04\
\0\x12event-predicate-op\x03\0\x0e\x01r\x03\x08col-names\x05value\x01\x02op\x0f\x04\
\0\x0fevent-predicate\x03\0\x10\x01j\x01s\x01s\x01@\x01\x0eevent-col-names\0\x12\
\x04\0\x1dinitialize-latest-event-state\x01\x13\x01@\x01\x0fevent-predicate\x11\0\
\x12\x04\0\x19initialize-tl-has-existed\x01\x14\x01@\x02\x0fevent-predicate\x11\x04\
timew\0\x12\x04\0\x20initialize-tl-has-existed-within\x01\x15\x01@\x01\x05event\x05\
\0\x12\x04\0\x09add-event\x01\x16\x01j\x01\x0d\x01s\x01@\x01\x02t1w\0\x17\x04\0\x15\
latest-event-to-state\x01\x18\x04\0\x0etl-has-existed\x01\x18\x04\0\x15tl-has-ex\
isted-within\x01\x18\x04\x01\x1ctimeline:event-processor/api\x05\0\x04\x01(timel\
ine:event-processor/event-processor\x04\0\x0b\x15\x01\0\x0fevent-processor\x03\0\
\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.208.1\x10wit-bi\
ndgen-rust\x060.25.0";

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
